nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
simulation_list[[s]] = list(
sim_data = sim_data, cnr_out = cnr_out, pre_bs = pre_bs, second_bs = second_bs, ind_bs = ind_bs, lnmr_L1 = lnmr_L1, lnmr_L3 = lnmr_L3, lnmr_L5 = lnmr_L5
)
if(s %% 2 == 0){
save(simulation_list_201, file = '~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/simulation_list_201.Rdata')
}
}
rm(list=ls())
source('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/simulate_misaligned.R')
compute_tchol_hatSigma_mat = function(cnr_out, ind = FALSE){
K = length(cnr_out$hatnu_vec_x)
m_n = dim(vec2symMat(cnr_out$dist_vec, diag = F))[1]
hatL_k_list = lapply(1:K, function(k){
t(chol(cnr_out$hatsigma2_vec_x[k] * vec2symMat(geoR::matern(u = cnr_out$dist_vec, kappa = cnr_out$hatnu_vec_x[k], phi = (1/(cnr_out$hatalpha_vec_x[k] ))), diag = F ) + cnr_out$hattau_vec_x[k] * diag(m_n)))
})
if(!ind){
hatR = cnr_out$hatR
diag(hatR) = 1
hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (hatR %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
#hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (cnr_out$hatR %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
}else{
hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (diag(K) %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
}
return(t(chol(hatSigma_mat)))
}
load('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/sim_loc.Rdata')
all_loc = rbind(sim_loc$x_loc,sim_loc$y_loc)
all_loc_sf = st_as_sf(all_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant")
sim_dist_mat =  st_distance(all_loc_sf)
sim_dist_vec = sim_dist_mat[lower.tri(sim_dist_mat)] / 1000
sim_dist_vec = as.numeric(sim_dist_vec)
sim_dist_mat_y_x = as.matrix(st_distance(st_as_sf(sim_loc$y_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"),
st_as_sf(sim_loc$x_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"))
)
#
set.seed(201)
n_sim = 2
T_bootstrap = 250
#List to store simulation results for each run
simulation_list_201 = vector("list", n_sim)
#Initialize true parameter values
K = 5
true_nu_vec_x = rep(0.5,K)
true_alpha_vec_x = rep(0.0015, K)
true_sigma2_vec_x = rep(1,K)
true_tau_vec_x = rep(0.15,K)
true_mu_vec_x = rep(0,K)
true_R <- outer(1:5, 1:5, FUN = "-") %>%
abs %>%
{0.5^{.}}
true_R[1,-1] = true_R[-1,1] = 0
true_R[2,-2] = true_R[-2,2] = 0
true_beta = c(2,1,0.5,1,0.5,1)
true_sigma2_rho = 0.2
true_nu_rho = 0.5
true_alpha_rho = 0.0015
true_tau_epsilon = 0.01
true_y_name = 'y'
true_x_name = paste0('X',1:K)
true_y_mean_model_formula = as.formula('~ X1 + X2 + X3 + X4 + X5')
for(s in 1:n_sim){
#Simulating Data
sim_data = simulate_misaligned(nu_vec_x = true_nu_vec_x, alpha_vec_x = true_alpha_vec_x, sigma2_vec_x = true_sigma2_vec_x, tau_vec_x = true_tau_vec_x, mu_vec_x = true_mu_vec_x, R_mat = true_R, beta_vec = true_beta, sigma2_rho = true_sigma2_rho, nu_rho = true_nu_rho, alpha_rho = true_alpha_rho, tau_epsilon = true_tau_epsilon, y_loc = sim_loc$y_loc, x_loc =  sim_loc$x_loc, y_name = true_y_name, x_name = true_x_name,
y_mean_model_formula =  true_y_mean_model_formula, spline_basis_list = NULL, cnr_step3_model_fit = NULL, gc_dist = TRUE,
bootstrap_use = FALSE, tchol_Sigma_mat = NULL, tchol_Sigma_err = NULL)
#Perform CNR
cnr_out = cnr(data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
nu_vec_x = true_nu_vec_x,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
#Perform Preliminary Bootstrap
pre_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Prelim', pre_bs = NULL)
#Perform Second Bootstrap
second_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Second', pre_bs = pre_bs)
#Perform Independent Bootstrap
ind_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Ind', pre_bs = pre_bs)
#Perform l-NMR with l = 1,3,5
lnmr_L1 = lnmr(l = 1, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L3 = lnmr(l = 3, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L5 = lnmr(l = 5, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
simulation_list[[s]] = list(
sim_data = sim_data, cnr_out = cnr_out, pre_bs = pre_bs, second_bs = second_bs, ind_bs = ind_bs, lnmr_L1 = lnmr_L1, lnmr_L3 = lnmr_L3, lnmr_L5 = lnmr_L5
)
if(s %% 2 == 0){
save(simulation_list_201, file = '~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/simulation_list_201.Rdata')
}
}
s
simulation_list_201[[s]] = list(
sim_data = sim_data, cnr_out = cnr_out, pre_bs = pre_bs, second_bs = second_bs, ind_bs = ind_bs, lnmr_L1 = lnmr_L1, lnmr_L3 = lnmr_L3, lnmr_L5 = lnmr_L5
)
rm(list=ls())
source('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/simulate_misaligned.R')
compute_tchol_hatSigma_mat = function(cnr_out, ind = FALSE){
K = length(cnr_out$hatnu_vec_x)
m_n = dim(vec2symMat(cnr_out$dist_vec, diag = F))[1]
hatL_k_list = lapply(1:K, function(k){
t(chol(cnr_out$hatsigma2_vec_x[k] * vec2symMat(geoR::matern(u = cnr_out$dist_vec, kappa = cnr_out$hatnu_vec_x[k], phi = (1/(cnr_out$hatalpha_vec_x[k] ))), diag = F ) + cnr_out$hattau_vec_x[k] * diag(m_n)))
})
if(!ind){
hatR = cnr_out$hatR
diag(hatR) = 1
hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (hatR %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
#hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (cnr_out$hatR %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
}else{
hatSigma_mat = as.matrix(bdiag(hatL_k_list)  %*% (diag(K) %x% diag(m_n) ) %*%  t( bdiag(hatL_k_list) ) )
}
return(t(chol(hatSigma_mat)))
}
load('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/sim_loc.Rdata')
all_loc = rbind(sim_loc$x_loc,sim_loc$y_loc)
all_loc_sf = st_as_sf(all_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant")
sim_dist_mat =  st_distance(all_loc_sf)
sim_dist_vec = sim_dist_mat[lower.tri(sim_dist_mat)] / 1000
sim_dist_vec = as.numeric(sim_dist_vec)
sim_dist_mat_y_x = as.matrix(st_distance(st_as_sf(sim_loc$y_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"),
st_as_sf(sim_loc$x_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"))
)
#
set.seed(201)
n_sim = 2
T_bootstrap = 250
#List to store simulation results for each run
simulation_list_201 = vector("list", n_sim)
#Initialize true parameter values
K = 5
true_nu_vec_x = rep(0.5,K)
true_alpha_vec_x = rep(0.0015, K)
true_sigma2_vec_x = rep(1,K)
true_tau_vec_x = rep(0.15,K)
true_mu_vec_x = rep(0,K)
true_R <- outer(1:5, 1:5, FUN = "-") %>%
abs %>%
{0.5^{.}}
true_R[1,-1] = true_R[-1,1] = 0
true_R[2,-2] = true_R[-2,2] = 0
true_beta = c(2,1,0.5,1,0.5,1)
true_sigma2_rho = 0.2
true_nu_rho = 0.5
true_alpha_rho = 0.0015
true_tau_epsilon = 0.01
true_y_name = 'y'
true_x_name = paste0('X',1:K)
true_y_mean_model_formula = as.formula('~ X1 + X2 + X3 + X4 + X5')
for(s in 1:n_sim){
#Simulating Data
sim_data = simulate_misaligned(nu_vec_x = true_nu_vec_x, alpha_vec_x = true_alpha_vec_x, sigma2_vec_x = true_sigma2_vec_x, tau_vec_x = true_tau_vec_x, mu_vec_x = true_mu_vec_x, R_mat = true_R, beta_vec = true_beta, sigma2_rho = true_sigma2_rho, nu_rho = true_nu_rho, alpha_rho = true_alpha_rho, tau_epsilon = true_tau_epsilon, y_loc = sim_loc$y_loc, x_loc =  sim_loc$x_loc, y_name = true_y_name, x_name = true_x_name,
y_mean_model_formula =  true_y_mean_model_formula, spline_basis_list = NULL, cnr_step3_model_fit = NULL, gc_dist = TRUE,
bootstrap_use = FALSE, tchol_Sigma_mat = NULL, tchol_Sigma_err = NULL)
#Perform CNR
cnr_out = cnr(data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
nu_vec_x = true_nu_vec_x,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
#Perform Preliminary Bootstrap
pre_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Prelim', pre_bs = NULL)
#Perform Second Bootstrap
second_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Second', pre_bs = pre_bs)
#Perform Independent Bootstrap
ind_bs = bootstrap_cnr(T_bootstrap = T_bootstrap, bootstrap_CI_level = 0.95, cnr_out = cnr_out, bootstrap_type = 'Ind', pre_bs = pre_bs)
#Perform l-NMR with l = 1,3,5
lnmr_L1 = lnmr(l = 1, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L3 = lnmr(l = 3, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L5 = lnmr(l = 5, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
simulation_list_201[[s]] = list(
sim_data = sim_data, cnr_out = cnr_out, pre_bs = pre_bs, second_bs = second_bs, ind_bs = ind_bs, lnmr_L1 = lnmr_L1, lnmr_L3 = lnmr_L3, lnmr_L5 = lnmr_L5
)
if(s %% 2 == 0){
save(simulation_list_201, file = '~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/simulation_list_201.Rdata')
}
}
#Results based on old script
load('Spatial misalignment R Codes/Rdata/simulation_list/simulation_list_201_K5_less_cor_BC.Rdata')
#Results based on old script
load('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Rdata/simulation_list/simulation_list_201_K5_less_cor_BC.Rdata')
#Comparing CNR results
#0 on laptop, 4.448075e-08 on CBE PC
max(abs(simulation_list_201[[1]]$cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta))
max(abs(simulation_list_201[[2]]$cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[2]]$hatbeta))
#Comparing Bootstrap results
#Difference is due to old script FORCING diagonals of hatR to be ones when generating bootstrap datasets in Step (i) of bootstrap procedures, but new script did not force that
#No difference here since the results of simulation_list_201 was obtained by function compute_tchol_hatSigma_mat() FORCING the diagonal entries of R_mat to be ones
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$pre_bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$pre_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$pre_bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$pre_bs$hatbeta_mat ))
#Also, old script had second_bs and ind_bs in the same loop, while new code separate second_bs and ind_bs into two different loops - so the ordering of random generated numbers (and hence bootstrap datasets) are different
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$second_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$ind_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$second_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$ind_bs$hatbeta_mat ))
apply(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[1]]$second_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[1]]$ind_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[2]]$second_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[2]]$ind_bs$hatbeta_mat,2,mean)
apply(simulation_list_201[[1]]$pre_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[1]]$second_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[1]]$ind_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$pre_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$second_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$ind_bs$hatbeta_mat,2,sd)
simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[1]]$second_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[1]]$ind_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[2]]$second_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[2]]$ind_bs$hatbeta_mat[1:3,]
#Note that this is obtained on my ZyGj PC, with the function compute_tchol_hatSigma_mat() FORCING the diagonal entries of R_mat to be ones, and
#and using separate loops for second_bs and ind_bs, with n_sim = 2, T_bootstrap = 250 for all three types of bootstrap.
load('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github/Simulation/simulation_list_201.Rdata')
#Comparing CNR results
#0 on laptop and ZyGj PC, 4.448075e-08 on CBE PC
max(abs(simulation_list_201[[1]]$cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta))
max(abs(simulation_list_201[[2]]$cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[2]]$hatbeta))
#Comparing Bootstrap results
#Difference is due to old script FORCING diagonals of hatR to be ones when generating bootstrap datasets in Step (i) of bootstrap procedures, but new script did not force that
#No difference here since the results of simulation_list_201 was obtained by function compute_tchol_hatSigma_mat() FORCING the diagonal entries of R_mat to be ones
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$pre_bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$pre_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$pre_bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$pre_bs$hatbeta_mat ))
#Also, old script had second_bs and ind_bs in the same loop, while new code separate second_bs and ind_bs into two different loops - so the ordering of random generated numbers (and hence bootstrap datasets) are different
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$second_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat - simulation_list_201[[1]]$ind_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$second_bs$hatbeta_mat ))
max(abs(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat - simulation_list_201[[2]]$ind_bs$hatbeta_mat ))
simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[1]]$second_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[1]]$ind_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[2]]$second_bs$hatbeta_mat[1:3,]
simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat[1:3,] - simulation_list_201[[2]]$ind_bs$hatbeta_mat[1:3,]
apply(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[1]]$second_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[1]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[1]]$ind_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1cokrig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[2]]$second_bs$hatbeta_mat,2,mean)
apply(simulation_list_201_K5_less_cor_BC[[2]]$bootstrap_list_0no_1krig_2fix_3yes$hatbeta_mat,2,mean) - apply(simulation_list_201[[2]]$ind_bs$hatbeta_mat,2,mean)
apply(simulation_list_201[[1]]$pre_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[1]]$second_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[1]]$ind_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$pre_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$second_bs$hatbeta_mat,2,sd)
apply(simulation_list_201[[2]]$ind_bs$hatbeta_mat,2,sd)
n_sim = 1
#
K = 5
true_nu_vec_x = rep(0.5,K)
true_alpha_vec_x = c(0.0015,0.0015, 0.0015, 0.0015, 0.0015)
true_sigma2_vec_x = rep(1,K)
true_tau_vec_x = c(0.15,0.15,0.15,0.15,0.15)
true_mu_vec_x = rep(0,K)
#need a positive definite R_vec
true_R <- outer(1:5, 1:5, FUN = "-") %>%
abs %>%
{0.5^{.}}
true_R[1,-1] = true_R[-1,1] = 0
true_R[2,-2] = true_R[-2,2] = 0
true_R
true_R_vec1 = true_R[lower.tri(true_R)]
true_beta = c(2,1,0.5,1,0.5,1)
true_sigma2_rho = 0.2
true_nu_rho = 0.5
true_alpha_rho = 0.0015
true_tau_epsilon = 0.01
true_y_name = 'y'
true_x_name = paste0('X',1:K)
true_y_mean_model_formula = as.formula('~ X1 + X2 + X3 + X4 + X5')
dist_mat_y_x = as.matrix(st_distance(st_as_sf(july2021_location_data$pollution_data, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"),
st_as_sf(july2021_location_data$weather_data, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"))
)
dist_mat_y_x = as.matrix(st_distance(st_as_sf(sim_loc$y_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"),
st_as_sf(sim_loc$x_loc, coords = c("lon", "lat"), crs = "WGS84", agr = "constant"))
)
set.seed(201)
for(s in 1:n_sim){
#Simulating Data
sim_data = simulate_misaligned(nu_vec_x = true_nu_vec_x, alpha_vec_x = true_alpha_vec_x, sigma2_vec_x = true_sigma2_vec_x, tau_vec_x = true_tau_vec_x, mu_vec_x = true_mu_vec_x, R_mat = true_R, beta_vec = true_beta, sigma2_rho = true_sigma2_rho, nu_rho = true_nu_rho, alpha_rho = true_alpha_rho, tau_epsilon = true_tau_epsilon, y_loc = sim_loc$y_loc, x_loc =  sim_loc$x_loc, y_name = true_y_name, x_name = true_x_name,
y_mean_model_formula =  true_y_mean_model_formula, spline_basis_list = NULL, cnr_step3_model_fit = NULL, gc_dist = TRUE,
bootstrap_use = FALSE, tchol_Sigma_mat = NULL, tchol_Sigma_err = NULL)
#Perform CNR
cnr_out = cnr(data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
nu_vec_x = true_nu_vec_x,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
#Perform l-NMR with l = 1,3,5
lnmr_L1 = lnmr(l = 1, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L3 = lnmr(l = 3, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L5 = lnmr(l = 5, dist_mat_y_x = sim_dist_mat_y_x,
data_x = sim_data$data_x,
data_y = sim_data$data_y,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = sim_data$loc_name,
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
}
load('Spatial misalignment R Codes/Rdata/simulation_list/simulation_list_201_K5_less_cor_BC.Rdata')
load('~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Rdata/simulation_list/simulation_list_201_K5_less_cor_BC.Rdata')
#sim_data
#max(abs(sim_data$tchol_Sigma_mat - tchol_true_Sigma_mat1))
#0 on laptop, but 3.330669e-16 on CBE PC
max(abs(sim_data$data_x[,true_x_name] - simulation_list_201_K5_less_cor_BC[[1]]$x_weather_vec))
#CNR
#0 on laptop, but 4.448075e-08 on CBE PC
max(abs(cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta))
#LNMR
#0 on laptop, but 3.450953e-08 on CBE PC
max(abs(lnmr_L1$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta_knn_nmr_L1))
#0 on laptop, but 1.65141e-08 on CBE PC
max(abs(lnmr_L3$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta_knn_nmr_L3))
#0 on laptop, but 5.681318e-09 on CBE PC
max(abs(lnmr_L5$hatbeta - simulation_list_201_K5_less_cor_BC[[1]]$hatbeta_knn_nmr_L5))
cnr_abs_diff = rep(NA, length(simulation_list_201_K5_less_cor_BC))
L1_abs_diff = rep(NA, length(simulation_list_201_K5_less_cor_BC))
L3_abs_diff = rep(NA, length(simulation_list_201_K5_less_cor_BC))
L5_abs_diff = rep(NA, length(simulation_list_201_K5_less_cor_BC))
for(i in 1:length(simulation_list_201_K5_less_cor_BC)){
data_x_i =  data.frame(matrix(simulation_list_201_K5_less_cor_BC[[i]]$x_weather_vec, nrow = 243, ncol = 5, byrow = FALSE, dimnames = list(c(),true_x_name)))
data_x_i = data.frame(data_x_i, sim_loc$x_loc)
data_y_i = data.frame(simulation_list_201_K5_less_cor_BC[[i]]$pollution_vec)
data_y_i = data.frame(data_y_i, sim_loc$y_loc)
colnames(data_y_i) = c(true_y_name, 'lon','lat')
print(i)
cnr_out = cnr(data_x = data_x_i,
data_y = data_y_i,
gc_dist = TRUE,
nu_vec_x = true_nu_vec_x,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = c('lon','lat'),
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L1 = lnmr(l = 1, dist_mat_y_x = dist_mat_y_x,
data_x = data_x_i,
data_y = data_y_i,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = c('lon','lat'),
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L3 = lnmr(l = 3, dist_mat_y_x = dist_mat_y_x,
data_x = data_x_i,
data_y = data_y_i,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = c('lon','lat'),
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
lnmr_L5 = lnmr(l = 5, dist_mat_y_x = dist_mat_y_x,
data_x = data_x_i,
data_y = data_y_i,
gc_dist = TRUE,
dist_vec = sim_dist_vec,
y_name = true_y_name,
x_name = true_x_name,
loc_name = c('lon','lat'),
slmm_formula = as.formula(paste(true_y_name,' ~ 1  +',
paste(true_x_name,collapse = '+'), ' + Matern(1|lon+lat)')),
nu_rho = true_nu_rho,
smooth_list = NULL, discretized_num = NULL, smooth_CI_level = NULL)
cnr_abs_diff[i] = max(abs(cnr_out$hatbeta - simulation_list_201_K5_less_cor_BC[[i]]$hatbeta))
L1_abs_diff[i] = max(abs(lnmr_L1$hatbeta - simulation_list_201_K5_less_cor_BC[[i]]$hatbeta_knn_nmr_L1))
L3_abs_diff[i] = max(abs(lnmr_L3$hatbeta - simulation_list_201_K5_less_cor_BC[[i]]$hatbeta_knn_nmr_L3))
L5_abs_diff[i] = max(abs(lnmr_L5$hatbeta - simulation_list_201_K5_less_cor_BC[[i]]$hatbeta_knn_nmr_L5))
}
#All zeros on laptop, but only very close to zeros on CBE PC
max(cnr_abs_diff[1:14])
#All zeros on laptop, but only very close to zeros on CBE PC
max(cnr_abs_diff[1:14]) == 0
max(L1_abs_diff[1:14]) == 0
max(L3_abs_diff[1:14]) == 0
max(L5_abs_diff[1:14]) == 0
R.Version()
1 - (1 * 0.8 * 0.88)
1 - (1 * 0.5 * 0.84)
1 - (1 * 0.8 )
1 - (1 * 0.8 * 0.88)
1 - 0.296
1 - (1 * 0.8)
rm(list=ls())
library(metaSEM)
library(geoR)
library(sf)
library(Matrix)
library(spaMM)
library(splines)
getwd()
here::i_am("Simulation/Template_Simulation_Script.R")
setwd("~/Phd Research Project/SAR and Random Effect/Spatial misalignment R Codes/Github")
here::i_am("Simulation/Template_Simulation_Script.R")
getwd()
